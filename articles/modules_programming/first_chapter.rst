第一章 子过程
=============

子过程定义语法如下：

.. code-block:: C
  :linenos:
  
  ;  过程声明 
  <过程名> proc [距离][语言] [uses <寄存器列表>][参数列表][VARARGS]
      <code here>
      ret
  <过程名> endp

*距离* 选项有以下几种取值：

* NEAR16
* FAR16
* NEAR32
* FAR32
* NEAR
* FAR
* flat
  
win32程序模式声明中指定了距离参数为flat，所以可以省略。

语言参数如下表所示：

+---------+--------------+--------------+------------------+
| 名称    | 恢复栈顶指针 | 参数入栈顺序 | 是否支持变长参数 |
+=========+==============+==============+==================+
| C       | 调用者       | 从右到左     | 是               |
+---------+--------------+--------------+------------------+
| stdcall | 被调用者     | 从右到左     | 是               |
+---------+--------------+--------------+------------------+
| syscall | 被调用者     | 从右到左     | 是               |
+---------+--------------+--------------+------------------+
| Pascal  | 被调用者     | 从左到右     | 否               |
+---------+--------------+--------------+------------------+
| Fortran | 被调用者     | 从左到右     | 否               |
+---------+--------------+--------------+------------------+
| Basic   | 被调用者     | 从左到右     | 否               |
+---------+--------------+--------------+------------------+

不指定语言参数，则默认为模式声明中指定的语言。

寄存器列表指定了子过程中可能修改的寄存器集合。
程序进入子过程，会自动将寄存器列表中的寄存器值压栈。
等子程序退出时恢复寄存器列表的值。
一般的写法为： ``uses ebx ebp esi edi``。
需要注意的是寄存器列表不用逗号分隔。
省略 ``uses <寄存器列表>`` 语句，可以用 ``puspad`` 指令代替，
该指令的作用是将所有32位的寄存器值压栈。

.. warning:: ret指令之前要加上popad指令

参数列表的格式为： ``参数名:类型``。

类型的取值有：

* byte
* word
* dword
* fword
* qword
* tword
* real4
* real8
* real10
* sbyte
* sword
* sdword

默认的类型值为 ``dword`` 。
所以如果是 ``dword`` 类型，则可以省略不写。
参数列表是通过逗号隔开的。

VARARG表示该子过程传入的变长参数。
该参数的栈指针修复一律是由调用者完成的。

.. note:: 
 栈顶指针修复是指子程序在退出之后，
 需要将栈顶指针恢复到调用子程序的指令时的栈顶指针所处的位置。
 通过对不同的调用方式的反汇编，可以看出，
 C的调用方式是在调用子程序之后添加指令add bsp, n，
 而其余的调用方式都是在子程序最后加上ret n（表示将栈顶指针回退n字节）

**子程序的调用**

子程序的调用在masm32中有两者方式。
假设子过程print有两个参数：
方式一是通过若干个push指令再加上一个call指令完成的。
如下所示：

.. code-block:: C
  :linenos:

  push var1; var1是一个局部变量
  push var2; var2是一个局部变量
  call print; 这里的入栈方式如果是从右到左，则
            ; 是var2对应第一个参数，var1对应第二个参数
            ; 否则就反过来

第二种方式专属于masm32，通过伪指令 ``Invoke`` 实现:

.. code-block:: C
  :linenos:

  Invoke print, var1, var2

一行代码就可以了，编译器会自动翻译成第一种方式中的代码。
如果子程序没有参数，则call/Invoke指令作用是相同的。

局部变量的定义方式：``local <var_name>:type``。
如果定义数组，则是如此方式：``local <var_name>[N]:type`` [1]_。
类型如果为dword，可以省略。

局部变量的存储和访问，在反汇编代码中是通过压栈实现的。
先将现有的ebp寄存器值压栈，然后将栈顶指针esp的值给ebp。
然后修改esp(减一个4字节的整数倍)的值。
例如参数为：dword和word类型，则减8（4字节对齐）。
访问局部变量时，通过ebp基址寻址实现的。
``mov eax, dword ptr [ebp]``，获取第一个dword参数(ebp的值比esp大8字节，指向的是两个变量压栈之前的位置)；
``movzx eax, word ptr [ebp-4]``，获取第二个word参数。

在将局部变量或者子程序参数地址传给子程序调用时，可以用 `addr` 伪指令。
addr伪指令会被反汇编为 ``lea`` 指令。

.. warning::
  如果Invoke/call语句执行之前，没有子程序的定义，必须在之前对子程序进行声明。

  格式：<子程序名> proto [距离] [语言] [参数列表]。

  距离和语言都可以不写，参数列表可以只保留类型。
  例如：print proto :dword, :dword
 
.. [1] 这和定义全局数组略有不同，例如 array    db      200 dup(?)
